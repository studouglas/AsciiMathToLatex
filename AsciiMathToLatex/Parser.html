<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Parser | AsciiMath to LaTeX</title>
<script>
!function(){var q=null;window.PR_SHOULD_USE_CONTINUATION=!0;
(function(){function R(a){function d(e){var b=e.charCodeAt(0);if(b!==92)return b;var a=e.charAt(1);return(b=r[a])?b:"0"<=a&&a<="7"?parseInt(e.substring(1),8):a==="u"||a==="x"?parseInt(e.substring(2),16):e.charCodeAt(1)}function g(e){if(e<32)return(e<16?"\\x0":"\\x")+e.toString(16);e=String.fromCharCode(e);return e==="\\"||e==="-"||e==="]"||e==="^"?"\\"+e:e}function b(e){var b=e.substring(1,e.length-1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g),e=[],a=
b[0]==="^",c=["["];a&&c.push("^");for(var a=a?1:0,f=b.length;a<f;++a){var h=b[a];if(/\\[bdsw]/i.test(h))c.push(h);else{var h=d(h),l;a+2<f&&"-"===b[a+1]?(l=d(b[a+2]),a+=2):l=h;e.push([h,l]);l<65||h>122||(l<65||h>90||e.push([Math.max(65,h)|32,Math.min(l,90)|32]),l<97||h>122||e.push([Math.max(97,h)&-33,Math.min(l,122)&-33]))}}e.sort(function(e,a){return e[0]-a[0]||a[1]-e[1]});b=[];f=[];for(a=0;a<e.length;++a)h=e[a],h[0]<=f[1]+1?f[1]=Math.max(f[1],h[1]):b.push(f=h);for(a=0;a<b.length;++a)h=b[a],c.push(g(h[0])),
h[1]>h[0]&&(h[1]+1>h[0]&&c.push("-"),c.push(g(h[1])));c.push("]");return c.join("")}function s(e){for(var a=e.source.match(/\[(?:[^\\\] ]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g),c=a.length,d=[],f=0,h=0;f<c;++f){var l=a[f];l==="("?++h:"\\"===l.charAt(0)&&(l=+l.substring(1))&&(l<=h?d[l]=-1:a[f]=g(l))}for(f=1;f<d.length;++f)-1===d[f]&&(d[f]=++x);for(h=f=0;f<c;++f)l=a[f],l==="("?(++h,d[h]||(a[f]="(?:")):"\\"===l.charAt(0)&&(l=+l.substring(1))&&l<=h&&
(a[f]="\\"+d[l]);for(f=0;f<c;++f)"^"===a[f]&&"^"!==a[f+1]&&(a[f]="");if(e.ignoreCase&&m)for(f=0;f<c;++f)l=a[f],e=l.charAt(0),l.length>=2&&e==="["?a[f]=b(l):e!=="\\"&&(a[f]=l.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return a.join("")}for(var x=0,m=!1,j=!1,k=0,c=a.length;k<c;++k){var i=a[k];if(i.ignoreCase)j=!0;else if(/[a-z]/i.test(i.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi,""))){m=!0;j=!1;break}}for(var r={b:8,t:9,n:10,v:11,
f:12,r:13},n=[],k=0,c=a.length;k<c;++k){i=a[k];if(i.global||i.multiline)throw Error(""+i);n.push("(?:"+s(i)+")")}return RegExp(n.join("|"),j?"gi":"g")}function S(a,d){function g(a){var c=a.nodeType;if(c==1){if(!b.test(a.className)){for(c=a.firstChild;c;c=c.nextSibling)g(c);c=a.nodeName.toLowerCase();if("br"===c||"li"===c)s[j]="\n",m[j<<1]=x++,m[j++<<1|1]=a}}else if(c==3||c==4)c=a.nodeValue,c.length&&(c=d?c.replace(/\r\n?/g,"\n"):c.replace(/[\t\n\r ]+/g," "),s[j]=c,m[j<<1]=x,x+=c.length,m[j++<<1|1]=
a)}var b=/(?:^|\s)nocode(?:\s|$)/,s=[],x=0,m=[],j=0;g(a);return{a:s.join("").replace(/\n$/,""),d:m}}function H(a,d,g,b){d&&(a={a:d,e:a},g(a),b.push.apply(b,a.g))}function T(a){for(var d=void 0,g=a.firstChild;g;g=g.nextSibling)var b=g.nodeType,d=b===1?d?a:g:b===3?U.test(g.nodeValue)?a:d:d;return d===a?void 0:d}function D(a,d){function g(a){for(var j=a.e,k=[j,"pln"],c=0,i=a.a.match(s)||[],r={},n=0,e=i.length;n<e;++n){var z=i[n],w=r[z],t=void 0,f;if(typeof w==="string")f=!1;else{var h=b[z.charAt(0)];
if(h)t=z.match(h[1]),w=h[0];else{for(f=0;f<x;++f)if(h=d[f],t=z.match(h[1])){w=h[0];break}t||(w="pln")}if((f=w.length>=5&&"lang-"===w.substring(0,5))&&!(t&&typeof t[1]==="string"))f=!1,w="src";f||(r[z]=w)}h=c;c+=z.length;if(f){f=t[1];var l=z.indexOf(f),B=l+f.length;t[2]&&(B=z.length-t[2].length,l=B-f.length);w=w.substring(5);H(j+h,z.substring(0,l),g,k);H(j+h+l,f,I(w,f),k);H(j+h+B,z.substring(B),g,k)}else k.push(j+h,w)}a.g=k}var b={},s;(function(){for(var g=a.concat(d),j=[],k={},c=0,i=g.length;c<i;++c){var r=
g[c],n=r[3];if(n)for(var e=n.length;--e>=0;)b[n.charAt(e)]=r;r=r[1];n=""+r;k.hasOwnProperty(n)||(j.push(r),k[n]=q)}j.push(/[\S\s]/);s=R(j)})();var x=d.length;return g}function v(a){var d=[],g=[];a.tripleQuotedStrings?d.push(["str",/^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/,q,"'\""]):a.multiLineStrings?d.push(["str",/^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,
q,"'\"`"]):d.push(["str",/^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/,q,"\"'"]);a.verbatimStrings&&g.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,q]);var b=a.hashComments;b&&(a.cStyleComments?(b>1?d.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,q,"#"]):d.push(["com",/^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\b|[^\n\r]*)/,q,"#"]),g.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h(?:h|pp|\+\+)?|[a-z]\w*)>/,q])):d.push(["com",
/^#[^\n\r]*/,q,"#"]));a.cStyleComments&&(g.push(["com",/^\/\/[^\n\r]*/,q]),g.push(["com",/^\/\*[\S\s]*?(?:\*\/|$)/,q]));if(b=a.regexLiterals){var s=(b=b>1?"":"\n\r")?".":"[\\S\\s]";g.push(["lang-regex",RegExp("^(?:^^\\.?|[+-]|[!=]=?=?|\\#|%=?|&&?=?|\\(|\\*=?|[+\\-]=|->|\\/=?|::?|<<?=?|>>?>?=?|,|;|\\?|@|\\[|~|{|\\^\\^?=?|\\|\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*("+("/(?=[^/*"+b+"])(?:[^/\\x5B\\x5C"+b+"]|\\x5C"+s+"|\\x5B(?:[^\\x5C\\x5D"+b+"]|\\x5C"+
s+")*(?:\\x5D|$))+/")+")")])}(b=a.types)&&g.push(["typ",b]);b=(""+a.keywords).replace(/^ | $/g,"");b.length&&g.push(["kwd",RegExp("^(?:"+b.replace(/[\s,]+/g,"|")+")\\b"),q]);d.push(["pln",/^\s+/,q," \r\n\t\u00a0"]);b="^.[^\\s\\w.$@'\"`/\\\\]*";a.regexLiterals&&(b+="(?!s*/)");g.push(["lit",/^@[$_a-z][\w$@]*/i,q],["typ",/^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/,q],["pln",/^[$_a-z][\w$@]*/i,q],["lit",/^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i,q,"0123456789"],["pln",/^\\[\S\s]?/,
q],["pun",RegExp(b),q]);return D(d,g)}function J(a,d,g){function b(a){var c=a.nodeType;if(c==1&&!x.test(a.className))if("br"===a.nodeName)s(a),a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)b(a);else if((c==3||c==4)&&g){var d=a.nodeValue,i=d.match(m);if(i)c=d.substring(0,i.index),a.nodeValue=c,(d=d.substring(i.index+i[0].length))&&a.parentNode.insertBefore(j.createTextNode(d),a.nextSibling),s(a),c||a.parentNode.removeChild(a)}}function s(a){function b(a,c){var d=
c?a.cloneNode(!1):a,e=a.parentNode;if(e){var e=b(e,1),g=a.nextSibling;e.appendChild(d);for(var i=g;i;i=g)g=i.nextSibling,e.appendChild(i)}return d}for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),d;(d=a.parentNode)&&d.nodeType===1;)a=d;c.push(a)}for(var x=/(?:^|\s)nocode(?:\s|$)/,m=/\r\n?|\n/,j=a.ownerDocument,k=j.createElement("li");a.firstChild;)k.appendChild(a.firstChild);for(var c=[k],i=0;i<c.length;++i)b(c[i]);d===(d|0)&&c[0].setAttribute("value",d);var r=j.createElement("ol");
r.className="linenums";for(var d=Math.max(0,d-1|0)||0,i=0,n=c.length;i<n;++i)k=c[i],k.className="L"+(i+d)%10,k.firstChild||k.appendChild(j.createTextNode("\u00a0")),r.appendChild(k);a.appendChild(r)}function p(a,d){for(var g=d.length;--g>=0;){var b=d[g];F.hasOwnProperty(b)?E.console&&console.warn("cannot override language handler %s",b):F[b]=a}}function I(a,d){if(!a||!F.hasOwnProperty(a))a=/^\s*</.test(d)?"default-markup":"default-code";return F[a]}function K(a){var d=a.h;try{var g=S(a.c,a.i),b=g.a;
a.a=b;a.d=g.d;a.e=0;I(d,b)(a);var s=/\bMSIE\s(\d+)/.exec(navigator.userAgent),s=s&&+s[1]<=8,d=/\n/g,x=a.a,m=x.length,g=0,j=a.d,k=j.length,b=0,c=a.g,i=c.length,r=0;c[i]=m;var n,e;for(e=n=0;e<i;)c[e]!==c[e+2]?(c[n++]=c[e++],c[n++]=c[e++]):e+=2;i=n;for(e=n=0;e<i;){for(var p=c[e],w=c[e+1],t=e+2;t+2<=i&&c[t+1]===w;)t+=2;c[n++]=p;c[n++]=w;e=t}c.length=n;var f=a.c,h;if(f)h=f.style.display,f.style.display="none";try{for(;b<k;){var l=j[b+2]||m,B=c[r+2]||m,t=Math.min(l,B),A=j[b+1],G;if(A.nodeType!==1&&(G=x.substring(g,
t))){s&&(G=G.replace(d,"\r"));A.nodeValue=G;var L=A.ownerDocument,o=L.createElement("span");o.className=c[r+1];var v=A.parentNode;v.replaceChild(o,A);o.appendChild(A);g<l&&(j[b+1]=A=L.createTextNode(x.substring(t,l)),v.insertBefore(A,o.nextSibling))}g=t;g>=l&&(b+=2);g>=B&&(r+=2)}}finally{if(f)f.style.display=h}}catch(u){E.console&&console.log(u&&u.stack||u)}}var E=window,y=["break,continue,do,else,for,if,return,while"],C=[[y,"auto,case,char,const,default,double,enum,extern,float,goto,inline,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],M=[C,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,delegate,dynamic_cast,explicit,export,friend,generic,late_check,mutable,namespace,nullptr,property,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],V=[C,"abstract,assert,boolean,byte,extends,final,finally,implements,import,instanceof,interface,null,native,package,strictfp,super,synchronized,throws,transient"],
N=[C,"abstract,as,base,bool,by,byte,checked,decimal,delegate,descending,dynamic,event,finally,fixed,foreach,from,group,implicit,in,interface,internal,into,is,let,lock,null,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var,virtual,where"],C=[C,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],O=[y,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
P=[y,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],W=[y,"as,assert,const,copy,drop,enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,pub,pure,ref,self,static,struct,true,trait,type,unsafe,use"],y=[y,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],Q=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)\b/,
U=/\S/,X=v({keywords:[M,N,C,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",O,P,y],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),F={};p(X,["default-code"]);p(D([],[["pln",/^[^<?]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\S\s]*?(?:--\>|$)/],["lang-",/^<\?([\S\s]+?)(?:\?>|$)/],["lang-",/^<%([\S\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",
/^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i] ]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);p(D([["pln",/^\s+/,q," \t\r\n"],["atv",/^(?:"[^"]*"?|'[^']*'?)/,q,"\"'"] ],[["tag",/^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/],["pun",/^[/<->]+/],
["lang-js",/^on\w+\s*=\s*"([^"]+)"/i],["lang-js",/^on\w+\s*=\s*'([^']+)'/i],["lang-js",/^on\w+\s*=\s*([^\s"'>]+)/i],["lang-css",/^style\s*=\s*"([^"]+)"/i],["lang-css",/^style\s*=\s*'([^']+)'/i],["lang-css",/^style\s*=\s*([^\s"'>]+)/i] ]),["in.tag"]);p(D([],[["atv",/^[\S\s]+/] ]),["uq.val"]);p(v({keywords:M,hashComments:!0,cStyleComments:!0,types:Q}),["c","cc","cpp","cxx","cyc","m"]);p(v({keywords:"null,true,false"}),["json"]);p(v({keywords:N,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:Q}),
["cs"]);p(v({keywords:V,cStyleComments:!0}),["java"]);p(v({keywords:y,hashComments:!0,multiLineStrings:!0}),["bash","bsh","csh","sh"]);p(v({keywords:O,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),["cv","py","python"]);p(v({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:2}),["perl","pl","pm"]);p(v({keywords:P,
hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb","ruby"]);p(v({keywords:C,cStyleComments:!0,regexLiterals:!0}),["javascript","js"]);p(v({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,throw,true,try,unless,until,when,while,yes",hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);p(v({keywords:W,cStyleComments:!0,multilineStrings:!0}),["rc","rs","rust"]);
p(D([],[["str",/^[\S\s]+/] ]),["regex"]);var Y=E.PR={createSimpleLexer:D,registerLangHandler:p,sourceDecorator:v,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ",prettyPrintOne:E.prettyPrintOne=function(a,d,g){var b=document.createElement("div");b.innerHTML="<pre>"+a+"</pre>";b=b.firstChild;g&&J(b,g,!0);K({h:d,j:g,c:b,i:1});
return b.innerHTML},prettyPrint:E.prettyPrint=function(a,d){function g(){for(var b=E.PR_SHOULD_USE_CONTINUATION?c.now()+250:Infinity;i<p.length&&c.now()<b;i++){for(var d=p[i],j=h,k=d;k=k.previousSibling;){var m=k.nodeType,o=(m===7||m===8)&&k.nodeValue;if(o?!/^\??prettify\b/.test(o):m!==3||/\S/.test(k.nodeValue))break;if(o){j={};o.replace(/\b(\w+)=([\w%+\-.:]+)/g,function(a,b,c){j[b]=c});break}}k=d.className;if((j!==h||e.test(k))&&!v.test(k)){m=!1;for(o=d.parentNode;o;o=o.parentNode)if(f.test(o.tagName)&&
o.className&&e.test(o.className)){m=!0;break}if(!m){d.className+=" prettyprinted";m=j.lang;if(!m){var m=k.match(n),y;if(!m&&(y=T(d))&&t.test(y.tagName))m=y.className.match(n);m&&(m=m[1])}if(w.test(d.tagName))o=1;else var o=d.currentStyle,u=s.defaultView,o=(o=o?o.whiteSpace:u&&u.getComputedStyle?u.getComputedStyle(d,q).getPropertyValue("white-space"):0)&&"pre"===o.substring(0,3);u=j.linenums;if(!(u=u==="true"||+u))u=(u=k.match(/\blinenums\b(?::(\d+))?/))?u[1]&&u[1].length?+u[1]:!0:!1;u&&J(d,u,o);r=
{h:m,c:d,j:u,i:o};K(r)}}}i<p.length?setTimeout(g,250):"function"===typeof a&&a()}for(var b=d||document.body,s=b.ownerDocument||document,b=[b.getElementsByTagName("pre"),b.getElementsByTagName("code"),b.getElementsByTagName("xmp")],p=[],m=0;m<b.length;++m)for(var j=0,k=b[m].length;j<k;++j)p.push(b[m][j]);var b=q,c=Date;c.now||(c={now:function(){return+new Date}});var i=0,r,n=/\blang(?:uage)?-([\w.]+)(?!\S)/,e=/\bprettyprint\b/,v=/\bprettyprinted\b/,w=/pre|xmp/i,t=/^code$/i,f=/^(?:pre|code|xmp)$/i,
h={};g()}};typeof define==="function"&&define.amd&&define("google-code-prettify",[],function(){return Y})})();}()
</script>
<script>
PR.registerLangHandler(PR.createSimpleLexer([[PR.PR_PLAIN,/^[ \n\r\t\v\f\0]+/,null," \n\r   \f\x00"],[PR.PR_STRING,/^"(?:[^"\\]|(?:\\.)|(?:\\\((?:[^"\\)]|\\.)*\)))*"/,null,'"']],[[PR.PR_LITERAL,/^(?:(?:0x[\da-fA-F][\da-fA-F_]*\.[\da-fA-F][\da-fA-F_]*[pP]?)|(?:\d[\d_]*\.\d[\d_]*[eE]?))[+-]?\d[\d_]*/,null],[PR.PR_LITERAL,/^-?(?:(?:0(?:(?:b[01][01_]*)|(?:o[0-7][0-7_]*)|(?:x[\da-fA-F][\da-fA-F_]*)))|(?:\d[\d_]*))/,null],[PR.PR_LITERAL,/^(?:true|false|nil)\b/,null],[PR.PR_KEYWORD,/^\b(?:__COLUMN__|__FILE__|__FUNCTION__|__LINE__|#available|#else|#elseif|#endif|#if|#line|arch|arm|arm64|associativity|as|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|dynamicType|else|enum|extension|fallthrough|final|for|func|get|guard|import|indirect|infix|init|inout|internal|i386|if|in|iOS|iOSApplicationExtension|is|lazy|left|let|mutating|none|nonmutating|operator|optional|OSX|OSXApplicationExtension|override|postfix|precedence|prefix|private|protocol|Protocol|public|required|rethrows|return|right|safe|self|set|static|struct|subscript|super|switch|throw|try|Type|typealias|unowned|unsafe|var|weak|watchOS|while|willSet|x86_64)\b/,null],[PR.PR_COMMENT,/^\/\/.*?[\n\r]/,null],[PR.PR_COMMENT,/^\/\*[\s\S]*?(?:\*\/|$)/,null],[PR.PR_PUNCTUATION,/^<<=|<=|<<|>>=|>=|>>|===|==|\.\.\.|&&=|\.\.<|!==|!=|&=|~=|~|\(|\)|\[|\]|{|}|@|#|;|\.|,|:|\|\|=|\?\?|\|\||&&|&\*|&\+|&-|&=|\+=|-=|\/=|\*=|\^=|%=|\|=|->|`|==|\+\+|--|\/|\+|!|\*|%|<|>|&|\||\^|\?|=|-|_/,null],[PR.PR_TYPE,/^\b(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\w+_t\b)/,null]]),["swift"]);
</script>
<style>
.pln{color:#1b181b}.str{color:#918b3b}.kwd{color:#7b59c0}.com{color:#9e8f9e}.typ{color:#516aec}.lit{color:#a65926}.clo,.opn,.pun{color:#1b181b}.tag{color:#ca402b}.atn{color:#a65926}.atv{color:#159393}.dec{color:#a65926}.var{color:#ca402b}.fun{color:#516aec}pre.prettyprint{background:#f7f3f7;color:#ab9bab;font-family:Menlo,Consolas,"Bitstream Vera Sans Mono","DejaVu Sans Mono",Monaco,monospace;font-size:12px;line-height:1.5;border:1px solid #d8cad8;padding:10px}ol.linenums{margin-top:0;margin-bottom:0}
body{min-width:200px;max-width:850px;margin:0 auto;padding:30px;}.chapter-nav{font-size: 10pt;}a:link,a:visited{color:#00f}.codeblock_name,code,pre.prettyprint{font-family:Monaco,"Lucida Console",monospace}body{font-size:14pt}.codeblock_name,.math,.seealso,code{font-size:10pt}.codeblock{page-break-inside:avoid;padding-bottom:15px}.math{text-indent:0}pre.prettyprint{font-size:10pt;padding:10px;border-radius:10px;border:none;white-space:pre-wrap}.codeblock_name{margin-top:1.25em;display:block}a:link{text-decoration:none}a:link:not(.lit):hover{color:#00f;text-decoration:underline}a:link:active{color:red}h4{padding-right:1.25em}h4.noheading{margin-bottom:0}h1{text-align:center}code{padding:2px}pre{-moz-tab-size:4;-o-tab-size:4;tab-size:4}p:not(.notp){margin:0;text-indent:2em}.two-col{list-style-type:none}.two-col li:before{content:'-';padding:5px;margin-right:5px;color:orange;background-color:#fff;display:inline-block}@media print{body{font-size:10pt}pre.prettyprint{font-size:8pt}.seealso{font-size:9pt}.codeblock_name,.math,code{font-size:8pt}.math{text-indent:0}}
 body {
	font-family: Helvetica, sans-serif;
}

p {
	text-indent: 0!important;
	margin-bottom: 1em!important;;
}

h4 {
	font-size: 20px;
}

.subtitle {
	font-weight: 400;
	font-size: 22px;
}

.center {
	text-align: center;
	margin: 0 auto;
	display: block;
}</style>
</head>
<body onload="prettyPrint()">
<section>
<h1>Parser | AsciiMath to LaTeX</h1>
<a name="1:1"><div class="section"><h4>1. Description</h4></a>
<p>The parser is initialized with the AsciiMath equation (as text), and encapsulates functionality
related to generating a structured representation of the equation and converting that structure
to LaTeX. The structure is derived from the grammar definition (in BNR form) presented below.
</p>

</div>
<a name="1:2"><div class="section"><h4>2. Grammar</h4></a>
<p>The following is a (slightly) modified version of the AsciiMath grammar from the <a href="http://asciimath.org">AsciiMath</a>
webpage. To the right of the grammar rules are more readable names for each type of symbol, which will
be used throughout the program. Note also that for the constant and unary symbols there are far too 
many to be listed below, the full list can be found on the <a href="http://asciimath.org">AsciiMath</a> homepage.
</p>

<div class="codeblock">
<span class="codeblock_name">{Grammar definition <a href="Parser.html#1:2">2</a>}</span>
<pre class="prettyprint lang-swift">
AsciiMath grammar (BNR)
c ::= [A-Za-z] | greek letters | numbers | other constant symbols    constantSymbols
u ::= sqrt | text | bb | other unary symbols for font commands       unarySymbols
b ::= frac | root | stackrel                                         binarySymbols
l ::= ( | [ | { | (: | {:                                            leftDelimiters
r ::= ) | ] | } | :) | :}                                            rightDelimiters
S ::= c | lEr | uS | bSS                                             simpleExpression
E ::= SE | S/S | S_S | S^S | S_S^S | S | EE                          expression
</pre>



</div>
</div>
<a name="1:3"><div class="section"><h4>3. Module Structure</h4></a>
<p>The parser class maintains several member variables and exposes two functions in its interface to parse the
equation and to convert it to LaTeX. 
</p>

<div class="codeblock">
<span class="codeblock_name">{<strong>parser.swift</strong> <a href="Parser.html#1:3">3</a>}</span>
<pre class="prettyprint lang-swift">
class Parser {
<span class="nocode pln">	{Parser member variables, <a href="Parser.html#1:4">4</a>}</span>
<span class="nocode pln">	{Parser constructor, <a href="Parser.html#1:4">4</a>}</span>
<span class="nocode pln">	{Parse input, <a href="Parser.html#1:5">5</a>}</span>
<span class="nocode pln">	{Convert to latex, <a href="Parser.html#1:6">6</a>}</span>
<span class="nocode pln">	{Private functions, <a href="Parser.html#1:7">7</a>}</span>
}
</pre>



</div>
</div>
<a name="1:4"><div class="section"><h4>4. Initialization &amp; Member Variables</h4></a>
<p>The class will be initialized with a string representing the AsciiMath equation, and will initialize
its own Lexer with that same equation. It was decided to keep the Lexer a private object of the parser
to simplify the interface, and to adhere to the principle of "information hiding". Since the
caller doesn't <emph>need</emph> to know about the lexer, it is kept hidden behind the parser's interface.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parser constructor <a href="Parser.html#1:4">4</a>}</span>
<pre class="prettyprint lang-swift">
init(amEquation: String) {
    self.amEquation = amEquation
    self.lexer = Lexer(amEquation: amEquation)
}
</pre>


<p class="seealso">Used in section <a href="Parser.html#1:3">3</a></p>
</div>
<p>The parser will keep a copy of the equation as well as a Lexer object which will both be initialized as soon as the
Parser is. Additionally, the root node of the generated AST will be stored in <code>astRoot</code> once parsing is completed.
If parsing fails, the <code>astRoot</code> will be nil.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parser member variables <a href="Parser.html#1:4">4</a>}</span>
<pre class="prettyprint lang-swift">
private let amEquation: String!
private var lexer: Lexer!
private var astRoot: Expression?
</pre>


<p class="seealso">Used in section <a href="Parser.html#1:3">3</a></p>
</div>
</div>
<a name="1:5"><div class="section"><h4>5. Parsing Input</h4></a>
<p>This function will parse the input, returning false if an error is encountered, and true otherwise. If the parsing is
successful, the member variable <code>astRoot</code> will store the value of the root node of the AST. Note that the core functionality
of the parser is not in this function, but the <code>getNextExpression</code> function instead.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse input <a href="Parser.html#1:5">5</a>}</span>
<pre class="prettyprint lang-swift">
func parseInput() -&gt; Bool {
	astRoot = getNextExpression()
	
	if astRoot != nil {
		return true
	} else {
		println("Error parsing input. AST is nil.")
		return false
	}
}
</pre>


<p class="seealso">Used in section <a href="Parser.html#1:3">3</a></p>
</div>
</div>
<a name="1:6"><div class="section"><h4>6. Converting to LaTeX</h4></a>
<p>Once the input is validated and parsed, the AST needs to be converted to LaTeX source code. There are several
of "cleanup" steps that need to be performed (removing extra spaces, using parentheses that match the equation height etc.).
Once the cleanup steps have completed, the resulting LaTeX string is returned.
</p>

<div class="codeblock">
<span class="codeblock_name">{Convert to latex <a href="Parser.html#1:6">6</a>}</span>
<pre class="prettyprint lang-swift">
func convertToLatex() -&gt; String {
	if astRoot != nil {
		var latexStr = astRoot!.toLatexString()
		latexStr = latexStr.stringByReplacingOccurrencesOfString("  ", withString: " ")
		latexStr = latexStr.stringByReplacingOccurrencesOfString("{(", withString: "{")
		latexStr = latexStr.stringByReplacingOccurrencesOfString(")}", withString: "}")
		latexStr = latexStr.stringByReplacingOccurrencesOfString(" }", withString: "}")
		latexStr = latexStr.stringByReplacingOccurrencesOfString(" _", withString: "_")
		latexStr = latexStr.stringByReplacingOccurrencesOfString(" ^", withString: "^")
		latexStr = latexStr.stringByReplacingOccurrencesOfString("(", withString: "\\left(")
		latexStr = latexStr.stringByReplacingOccurrencesOfString(")", withString: "\\right)")
		return latexStr
	} else {
		println("Error converting to LaTeX. AST is nil.")
		return ""
	}
}
</pre>


<p class="seealso">Used in section <a href="Parser.html#1:3">3</a></p>
</div>
</div>
<a name="1:7"><div class="section"><h4>7. Private Functions</h4></a>
<p>The two private functions for getting the next expression or simple expression contain the core functionality
of the Parser. These functions use the AsciiMath grammar to generate an AST representing the input equation.
</p>

<div class="codeblock">
<span class="codeblock_name">{Private functions <a href="Parser.html#1:7">7</a>}</span>
<pre class="prettyprint lang-swift">
<span class="nocode pln">{Get next simple expression, <a href="Parser.html#1:8">8</a>}</span>
<span class="nocode pln">{Get next expression, <a href="Parser.html#1:9">9</a>}</span>
</pre>


<p class="seealso">Used in section <a href="Parser.html#1:3">3</a></p>
</div>
</div>
<a name="1:8"><div class="section"><h4>8. Simple Expression</h4></a>
<p>This function will return the next simple expression in the text, as per the grammar definition. If no simple expression
follows the current location in the string, or if an error is encountered, <code>nil</code> is returned.
</p>

<div class="codeblock">
<span class="codeblock_name">{Get next simple expression <a href="Parser.html#1:8">8</a>}</span>
<pre class="prettyprint lang-swift">
private func getNextSimpleExpression() -&gt; SimpleExpression? {
	var currentSymbolOpt = lexer.getNextSymbol()
	if currentSymbolOpt == nil {
		println("Error. Expected symbol in simple expression")
		return nil
	}
	if contains(expressionSymbols, currentSymbolOpt!) {
		currentSymbolOpt = lexer.getNextSymbol()
		if (currentSymbolOpt == nil) {
			println("Error. Expected symbol after expression operator")
			return nil
		}
	}
	let currentSymbol = currentSymbolOpt!

	if contains(leftDelimiters, currentSymbol) {
<span class="nocode pln">		{Parse lEr rule, <a href="Parser.html#1:8">8</a>}</span>
	} else if contains(unarySymbols, currentSymbol) {
<span class="nocode pln">		{Parse uS rule, <a href="Parser.html#1:8">8</a>}</span>
	} else if contains(binarySymbols, currentSymbol) {
<span class="nocode pln">		{Parse bSS rule, <a href="Parser.html#1:8">8</a>}</span>
	} else {
		return ConstantSE(str: currentSymbol)
	}
}
</pre>


<p class="seealso">Used in section <a href="Parser.html#1:7">7</a></p>
</div>
<p>If we are matching to the <code>lEr</code> rule (an expression delimited by brackets, braces or parentheses) we need to ensure
that after we have the <code>E</code>, the correct closing delimiter occurs. If this is indeed the case (as it should be), we want
to ignore that closing delimiter by increasing the lexer's current location in the string.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse lEr rule <a href="Parser.html#1:8">8</a>}</span>
<pre class="prettyprint lang-swift">
if let nextExpression = getNextExpression() {
	let delimType = DelimiterType(str: currentSymbol)
	if let nextChar = lexer.peekNextCharacter() where String(nextChar) == delimType.rightString() {
		lexer.currentLoc++
		return DelimitedSE(expr: nextExpression, bracketType: delimType)
	} else {
		println("Error. '\(delimType.rightString())' expected after expression '\(nextExpression.toString())'")
		return nil
	} 
} else {
	println("Error. expected expression after '\(currentSymbol)'")
	return nil
}
</pre>



</div>
<p>A unary operator followed by a simple expression is a relatively straightforward case. The only possible error is if
there is not a simple expression following the operator.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse uS rule <a href="Parser.html#1:8">8</a>}</span>
<pre class="prettyprint lang-swift">
if let nextSimpleExpression = getNextSimpleExpression() {
	return UnarySE(op: currentSymbol, simpleExpr: nextSimpleExpression)
} else {
	println("Error. Simple expression expected after '\(currentSymbol)'")
	return nil
}
</pre>



</div>
<p>The binary operator is a similar case to the unary operator, except that we require 
two simple expressions to follow the operator.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse bSS rule <a href="Parser.html#1:8">8</a>}</span>
<pre class="prettyprint lang-swift">
if let nextSimpleExpression = getNextSimpleExpression(), 
	   finalSimpleExpression = getNextSimpleExpression() {
	return BinarySE(op: currentSymbol, leftSE: nextSimpleExpression, rightSE: finalSimpleExpression)
} else {
	println("Error. Simple expression expected after '\(currentSymbol)'")
	return nil
}
</pre>



</div>
</div>
<a name="1:9"><div class="section"><h4>9. Expression</h4></a>
<p>Parsing expressions is a little more complex than simple expressions (as can be expected). All parse rules for 
expressions start with a simple expression (except <code>EE</code>, but that's a special case). So firstly we get the next
simple expression and verify it is non-nil. We then check the character following that simple expression. If we're
at the end of our string or it's a right delimiter, we just return the simple expression we fetched initially. If
it is not one of the special expression symbols ['_','^','/'], then it must be the beginning of a new expression, i.e.
the <code>SE</code> rule in our grammar. In all these cases, the appropriate Expression object is returned and the function exits.
</p>
<p>After addressing all those cases, we know that the next expression must be a fraction or a sub/super-script. When we
parse this, we do generate the Expression object representing it, but do not return it immediately. This is because 
we must check if there is another expression following it. If there is, we return a sequence expression consisting of the first
fraction or sub/super-script expression followed by the next expression (which could be any of the possible expression types).
</p>

<div class="codeblock">
<span class="codeblock_name">{Get next expression <a href="Parser.html#1:9">9</a>}</span>
<pre class="prettyprint lang-swift">
private func getNextExpression() -&gt; Expression? {
	let simpleExpressionOpt = getNextSimpleExpression()
	if (simpleExpressionOpt == nil) {
		return nil
	}
	let simpleExpression = simpleExpressionOpt!
	var currentExpression: Expression?
	var nextCharacter = lexer.peekNextCharacter()

	if nextCharacter == nil || contains(rightDelimiters, String(nextCharacter!)) {
		return SimpleExpressionE(simpleExpr: simpleExpression)
	}
	
	if !contains(expressionSymbols, String(nextCharacter!)) {
<span class="nocode pln">		{Parse SE rule, <a href="Parser.html#1:9">9</a>}</span>
	}
	
	if let nextSimpleExpression = getNextSimpleExpression() {
		switch (nextCharacter!) {		
		case "/":
			currentExpression = FractionE(top: simpleExpression, bottom: nextSimpleExpression)

		case "_":
			if (lexer.peekNextCharacter() == "^") {
<span class="nocode pln">				{Parse S_S^S rule, <a href="Parser.html#1:9">9</a>}</span>
			} else {
				currentExpression = SubscriptE(base: simpleExpression, sub: nextSimpleExpression)
			}

		case "^":
			currentExpression = SuperscriptE(base: simpleExpression, superscript: nextSimpleExpression)
		
		default: break
		}

<span class="nocode pln">		{Check for EE rule, <a href="Parser.html#1:9">9</a>}</span>
		
	}
	return currentExpression
}
</pre>


<p class="seealso">Used in section <a href="Parser.html#1:7">7</a></p>
</div>
<p>The most common type of expression consists of a simple expression followed by another expression. In this case, the
only possible error (since we already verified the simple expression) would be no expression following it.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse SE rule <a href="Parser.html#1:9">9</a>}</span>
<pre class="prettyprint lang-swift">
if let nextExpression = getNextExpression() {
	return SimpleSequenceE(simpleExpr: simpleExpression, expr: nextExpression)
} else {
	println("Error. Expression in SE case expected following '\(simpleExpression.toString())'")
	return nil
}
</pre>



</div>
<p>This is a more complex case of sub or superscript. Note that the subscript must come first, as per AsciiMath standard. The
possible error (since we've already verified the first two simple expressions) is that the third simple expression, the superscript,
does not exist.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse S_S^S rule <a href="Parser.html#1:9">9</a>}</span>
<pre class="prettyprint lang-swift">
if let finalSimpleExpression = getNextSimpleExpression() {
	currentExpression = SubSuperscriptE(base: simpleExpression, sub: nextSimpleExpression, superscript: finalSimpleExpression)	
} else {
	println("Error. Simple expression expected following '\(simpleExpression.toString())_\(nextSimpleExpression.toString())^'")
	return nil
}
</pre>



</div>
<p>If we haven't reached the end of our string, there is a possibility that there is another expression following the
one we just parsed. If this is the case, we return the appropriate sequence expression. We must also check that the
next character is not a right delimiter, as right delimiters indicate the end of an expression contained within the 
<code>lEr</code> simple expression rule.
</p>

<div class="codeblock">
<span class="codeblock_name">{Check for EE rule <a href="Parser.html#1:9">9</a>}</span>
<pre class="prettyprint lang-swift">
if currentExpression != nil &amp;&amp; lexer.currentLoc &lt; count(amEquation) - 1
&amp;&amp; !contains(rightDelimiters, String(lexer.peekNextCharacter()!)) {
	if let nextE = getNextExpression() {
		return SequenceE(e1: currentExpression!, e2: nextE)
	} else {
		println("Error. No expression found after '\(currentExpression)', but haven't reached end of equation.")
		return currentExpression
	}
}
</pre>



</div>

</div>
</body>
