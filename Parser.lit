@title AsciiMath to LaTeX Parser in Swift (P0.py)

@s Introduction
**intro here**

@s Grammar
--- Grammar definition
/* AsciiMath grammar
c ::= [A-Za-z] | greek letters | numbers | other constant symbols    constantSymbols
u ::= sqrt | text | bb | other unary symbols for font commands       unarySymbols
b ::= frac | root | stackrel                                         binarySymbols
l ::= ( | [ | { | (: | {:                                            leftBrackets
r ::= ) | ] | } | :) | :}                                            rightBrackets
S ::= c | lEr | uS | bSS                                             simpleExpression
E ::= SE | S/S | S_S | S^S | S_S^S | S                               expression
*/
---

--- parser.swift
@{Imports}
class Parser {
	@{Member variables}
	@{Constructor}
	@{Parse input}
	@{Convert to latex}
	@{Process next expression}
}
---

We will need the core functionality of Foundation for string processing and reading from stdin.
--- Imports
import Foundation
---

The class will be initialized with a string representing the AsciiMath equation.
--- Constructor
init(amEquation: String) {
    println("Parser initialized with: '\(amEquation)'")
    self.amEquation = amEquation
    self.lexer = Lexer(amEquation: amEquation)
}
---

The parser will need to keep track of several global variables.
--- Member variables
var errorMessage: String = ""
var amEquation: String = ""
var astRoot: Expression?
var lexer: Lexer!
---

This function will parse the input, and return false if an error is encountered, also setting
a member variable with the error string before returning false. If no error is encountered, true
will be returned.
--- Parse input
func parseInput() -> Bool {
	astRoot = getNextExpression()
	
	if astRoot != nil {
		return true
	} else {
		println("Error parsing input. AST is nil.")
		return false
	}
}
---

Once the input is validated and parsed, the AST needs to be converted to LaTeX source code.
--- Convert to latex
func convertToLatex() -> String {
	if astRoot != nil {
		return astRoot!.toLatexString()
	} else {
		println("Error converting to LaTeX. AST is nil.")
		return ""
	}
}
---

--- Process next expression
@{Get next simple expression}
@{Get next expression}
---

--- Get next simple expression
func getNextSimpleExpression() -> SimpleExpression? {
	// println("getNextSimpleExpression...")
	var currentSymbolOpt = lexer.getNextSymbol()
	if (currentSymbolOpt == nil) {
		println("Error. Expected symbol in getNextSimpleExpression")
		return nil
	}
	if (currentSymbolOpt! == "/" || currentSymbolOpt! == "_" || currentSymbolOpt! == "^") {
		currentSymbolOpt = lexer.getNextSymbol()
		if (currentSymbolOpt == nil) {
			println("Error. Expected non-nil symbol after /,_/^ in getNextSimpleExpression")
			return nil
		}
	}
	let currentSymbol = currentSymbolOpt!
	
	switch (String(currentSymbol)) {
		// lEr
		case "[":
			if let nextExpression = getNextExpression() {
				if let nextChar = lexer.peekNextCharacter() where String(nextChar) == "]" {
					return DelimitedSE(expr: nextExpression, bracketType: .Bracket)
				} else {
					println("Error. ']' expected after expression.")
					return nil
				} 
			} else {
				println("Error. expected expression after '\(currentSymbol)'")
				return nil
			}
		case "{":
			if let nextExpression = getNextExpression() {
				if let nextChar = lexer.peekNextCharacter() where String(nextChar) == "}" {
					return DelimitedSE(expr: nextExpression, bracketType:.Brace)
				} else {
					println("Error. '}' expected after expression.")
					return nil
				} 
			} else {
				println("Error. expected expression after '\(currentSymbol)'")
				return nil
			}
		case "(":
			if let nextExpression = getNextExpression() {
				if let nextChar = lexer.peekNextCharacter() where String(nextChar) == ")" {
					return DelimitedSE(expr: nextExpression, bracketType:.Paren)
				} else {
					println("Error. ')' expected after expression. nextExpression = '\(nextExpression.toString())'")
					return nil
				} 
			} else {
				println("Error. expected expression after '\(currentSymbol)'")
				return nil
			}

		// uS
		case "sqrt","text","bb":
			if let nextSimpleExpression = getNextSimpleExpression() {
				return UnarySE(op: currentSymbol, simpleExpr: nextSimpleExpression)
			} else {
				println("Error. simple expression expected after \(currentSymbol)")
				return nil
			}
		
		// bSS
		case "frac","root","stackrel":
			if let nextSimpleExpression = getNextSimpleExpression() {
				if let finalSimpleExpression = getNextSimpleExpression() {
					return BinarySE(op: currentSymbol, leftSE: nextSimpleExpression, rightSE: finalSimpleExpression)
				} else {
					println("Error. Simple expression expected after '\(currentSymbol)'")
					return nil	
				}
			} else {
				println("Error. Simple expression expected after '\(currentSymbol)'")
				return nil
			}
		// c
		default:
			return ConstantSE(str: currentSymbol)
	}
}
---

--- Get next expression
func getNextExpression() -> Expression? {
	let simpleExpressionOpt = getNextSimpleExpression()
	if (simpleExpressionOpt == nil) {
		println("Next simpleExpression nil in getNextExpression")
		return nil
	}
	let simpleExpression = simpleExpressionOpt!
	var currentExpression: Expression?
	let nextCharacter = lexer.peekNextCharacter()
	
	// S
	if (nextCharacter == nil || nextCharacter == ")") {
		return SimpleExpressionE(simpleExpr: simpleExpression)
	}
	
	// SE
	if nextCharacter != "/" && nextCharacter != "_" && nextCharacter != "^" {
		if let nextExpression = getNextExpression() {
			return SequenceE(simpleExpr: simpleExpression, expr: nextExpression)
		} else {
			println("Error. Expression in SE case expected following '\(simpleExpression.toString())'")
			return nil
		}
	}
	
	if let nextSimpleExpression = getNextSimpleExpression() {
		switch (nextCharacter!) {
		// S/S
		case "/":
			currentExpression = FractionE(top: simpleExpression, bottom: nextSimpleExpression)

		case "_":
			// S_S^S
			if (lexer.peekNextCharacter() == "^") {
				if let finalSimpleExpression = getNextSimpleExpression() {
					currentExpression = SubSuperscriptE(base: simpleExpression, sub: nextSimpleExpression, superscript: finalSimpleExpression)	
				} else {
					println("Error. Simple expression expected following '\(simpleExpression.toString())_\(nextSimpleExpression.toString())^'")
					return nil
				}
				
			} 
			// S_S
			else {
				currentExpression = SubscriptE(base: simpleExpression, sub: nextSimpleExpression)
			}
		
		// S^S
		case "^":
			currentExpression = SuperscriptE(base: simpleExpression, superscript: nextSimpleExpression)
		
		default: break
		}

		// EE
		if currentExpression != nil && lexer.currentIndex < count(amEquation) - 1 {
			if let nextE = getNextExpression() {
				return SequenceExprE(e1: currentExpression!, e2: nextE)
			} else {
				println("Error. No expression found after '\(currentExpression)', but haven't reached end of equation.")
				return currentExpression
			}
		}
	}

	return currentExpression
}
---

